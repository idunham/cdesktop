/*
 * CDE - Common Desktop Environment
 *
 * Copyright (c) 1993-2012, The Open Group. All rights reserved.
 *
 * These libraries and programs are free software; you can
 * redistribute them and/or modify them under the terms of the GNU
 * Lesser General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * These libraries and programs are distributed in the hope that
 * they will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with these librararies and programs; if not, write
 * to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
 * Floor, Boston, MA 02110-1301 USA
 */
/* A lexical scanner generated by flex */

/* scanner skeleton version:
 * $XConsortium: ps.cc /main/5 1996/08/05 17:05:45 drk $
 */

#define FLEX_SCANNER

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>

#if defined(__osf__) || defined(linux) || defined(CSRG_BASED)
#include <unistd.h>
#else
#if !defined(__uxp__) && !defined(USL)
#include <osfcn.h>
#endif
#endif

/* use prototypes in function declarations */
#define ps_USE_PROTOS

/* the "const" storage-class-modifier is valid */
#define ps_USE_CONST

#else	/* ! __cplusplus */

#ifdef __STDC__

#ifdef __GNUC__
#include <stddef.h>
void *malloc( size_t );
void free( void* );
#else
#include <stdlib.h>
#endif	/* __GNUC__ */

#define ps_USE_PROTOS
#define ps_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */


#ifdef __TURBOC__
#define ps_USE_CONST
#endif


#ifndef ps_USE_CONST
#define const
#endif


#ifdef ps_USE_PROTOS
#define ps_PROTO(proto) proto
#else
#define ps_PROTO(proto) ()
/* we can't get here if it's an ANSI C compiler, or a C++ compiler,
 * so it's got to be a K&R compiler, and therefore there's no standard
 * place from which to include these definitions
 */
char *malloc();
int free();
int read();
#endif


/* amount of stuff to slurp up with each read */
#ifndef ps_READ_BUF_SIZE
#define ps_READ_BUF_SIZE 8192
#endif

/* returned upon end-of-file */
#define ps_END_TOK 0

/* copy whatever the last rule matched to the standard output */

/* cast to (char *) is because for 8-bit chars, pstext is (unsigned char *) */
/* this used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite()
 */
#define ECHO (void) fwrite( (char *) pstext, psleng, 1, psout )

/* gets input and stuffs it into "buf".  number of characters read, or ps_NULL,
 * is returned in "result".
 */
#define ps_INPUT(buf,result,max_size) \
	if ( (result = read( fileno(psin), (char *) buf, max_size )) < 0 ) \
	    ps_FATAL_ERROR( "read() in flex scanner failed" );
#define ps_NULL 0

/* no semi-colon after return; correct usage is to write "psterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#define psterminate() return ( ps_NULL )

/* report a fatal error */

/* The funky do-while is used to turn this macro definition into
 * a single C statement (which needs a semi-colon terminator).
 * This avoids problems with code like:
 *
 * 	if ( something_happens )
 *		ps_FATAL_ERROR( "oops, the something happened" );
 *	else
 *		everything_okay();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the ps_FATAL_ERROR() call.
 */

#define ps_FATAL_ERROR(msg) \
	do \
		{ \
		(void) fputs( msg, stderr ); \
		(void) putc( '\n', stderr ); \
		exit( 1 ); \
		} \
	while ( 0 )

/* default pswrap function - always treat EOF as an EOF */
#define pswrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN ps_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define ps_STATE_EOF(state) (ps_END_OF_BUFFER + state + 1)

/* special action meaning "start processing a new file" */
#define ps_NEW_FILE \
	do \
		{ \
		ps_init_buffer( ps_current_buffer, psin ); \
		ps_load_buffer_state(); \
		} \
	while ( 0 )

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define ps_DECL int pslex ps_PROTO(( void )) 

/* code executed at the end of each rule */
#define ps_BREAK break;

#define ps_END_OF_BUFFER_CHAR 0

#ifndef ps_BUF_SIZE
#define ps_BUF_SIZE (ps_READ_BUF_SIZE * 2) /* size of default input buffer */
#endif

typedef struct ps_buffer_state *ps_BUFFER_STATE;

#define ps_CHAR unsigned char
# line 1 "ps.l"
#define INITIAL 0
/*
* $XConsortium: ps.cc /main/5 1996/08/05 17:05:45 drk $
*
* Copyright (c) 1993 HAL Computer Systems International, Ltd.
* All rights reserved.  Unpublished -- rights reserved under
* the Copyright Laws of the United States.  USE OF A COPYRIGHT
* NOTICE IS PRECAUTIONARY ONLY AND DOES NOT IMPLY PUBLICATION
* OR DISCLOSURE.
* 
* THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE
* SECRETS OF HAL COMPUTER SYSTEMS INTERNATIONAL, LTD.  USE,
* DISCLOSURE, OR REPRODUCTION IS PROHIBITED WITHOUT THE
* PRIOR EXPRESS WRITTEN PERMISSION OF HAL COMPUTER SYSTEMS
* INTERNATIONAL, LTD.
* 
*                         RESTRICTED RIGHTS LEGEND
* Use, duplication, or disclosure by the Government is subject
* to the restrictions as set forth in subparagraph (c)(l)(ii)
* of the Rights in Technical Data and Computer Software clause
* at DFARS 252.227-7013.
*
*          HAL COMPUTER SYSTEMS INTERNATIONAL, LTD.
*                  1315 Dell Avenue
*                  Campbell, CA  95008
* 
*/
# line 37 "ps.l"

#include "compression/trie.h"
#include "compression/abs_agent.h"

static unsigned char psbuf[LBUFSIZ];
static int psbuf_sz = LBUFSIZ;
static int psbuffed = 0;
              
#undef pswrap
int pswrap();

#undef ps_INPUT
#define ps_INPUT(buf,result,max_size) \
   { \
      result = (*fill_buf_func)((unsigned char*)buf,max_size); \
   }


# line 57 "ps.l"

/* done after the current pattern has been matched and before the
 * corresponding action - sets up pstext
 */
#define ps_DO_BEFORE_ACTION \
	pstext = ps_bp; \
	psleng = ps_cp - ps_bp; \
	ps_hold_char = *ps_cp; \
	*ps_cp = '\0'; \
	ps_c_buf_p = ps_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define psless(n) \
	do \
		{ \
		/* undo effects of setting up pstext */ \
		*ps_cp = ps_hold_char; \
		ps_c_buf_p = ps_cp = ps_bp + n; \
		ps_DO_BEFORE_ACTION; /* set up pstext again */ \
		} \
	while ( 0 )

#define unput(c) psunput( c, pstext )


struct ps_buffer_state
    {
    FILE *ps_input_file;

    ps_CHAR *ps_ch_buf;		/* input buffer */
    ps_CHAR *ps_buf_pos;	/* current position in input buffer */

    /* size of input buffer in bytes, not including room for EOB characters*/
    int ps_buf_size;	

    /* number of characters read into ps_ch_buf, not including EOB characters */
    int ps_n_chars;

    int ps_eof_status;		/* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
    /* "pending" happens when the EOF has been seen but there's still
     * some text process
     */
#define EOF_PENDING 1
#define EOF_DONE 2
    };

static ps_BUFFER_STATE ps_current_buffer;

/* we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */
#define ps_CURRENT_BUFFER ps_current_buffer


/* ps_hold_char holds the character lost when pstext is formed */
static ps_CHAR ps_hold_char;

static int ps_n_chars;		/* number of characters read into ps_ch_buf */



#ifndef ps_USER_ACTION
#define ps_USER_ACTION
#endif

#ifndef ps_USER_INIT
#define ps_USER_INIT
#endif

extern ps_CHAR *pstext;
extern int psleng;
extern FILE *psin, *psout;

ps_CHAR *pstext;
int psleng;

FILE *psin = (FILE *) 0, *psout = (FILE *) 0;

#define ps_END_OF_BUFFER 3
typedef int ps_state_type;
static const short int ps_accept[6] =
    {   0,
        0,    0,    3,    1,    0
    } ;

static const ps_CHAR ps_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const ps_CHAR ps_meta[3] =
    {   0,
        1,    1
    } ;

static const short int ps_base[6] =
    {   0,
        0,    0,    3,    4,    4
    } ;

static const short int ps_def[6] =
    {   0,
        5,    1,    5,    5,    0
    } ;

static const short int ps_nxt[7] =
    {   0,
        4,    4,    5,    3,    5,    5
    } ;

static const short int ps_chk[7] =
    {   0,
        1,    1,    3,    5,    5,    5
    } ;

static ps_state_type ps_last_accepting_state;
static ps_CHAR *ps_last_accepting_cpos;

/* the intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed
 */
#define REJECT reject_used_but_not_detected
#define psmore() psmore_used_but_not_detected
#define ps_MORE_ADJ 0

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
/* points to current character in buffer */
static ps_CHAR *ps_c_buf_p = (ps_CHAR *) 0;
static int ps_init = 1;		/* whether we need to initialize */
static int ps_start = 0;	/* start state number */

/* flag which is used to allow pswrap()'s to do buffer switches
 * instead of setting up a fresh psin.  A bit of a hack ...
 */
static int ps_did_buffer_switch_on_eof;

static ps_state_type ps_get_previous_state ps_PROTO(( void ));
static ps_state_type ps_try_NUL_trans ps_PROTO(( ps_state_type current_state ));
static int ps_get_next_buffer ps_PROTO(( void ));
static void psunput ps_PROTO(( ps_CHAR c, ps_CHAR *buf_ptr ));
void psrestart ps_PROTO(( FILE *input_file ));
void ps_switch_to_buffer ps_PROTO(( ps_BUFFER_STATE new_buffer ));
void ps_load_buffer_state ps_PROTO(( void ));
ps_BUFFER_STATE ps_create_buffer ps_PROTO(( FILE *file, int size ));
void ps_delete_buffer ps_PROTO(( ps_BUFFER_STATE b ));
void ps_init_buffer ps_PROTO(( ps_BUFFER_STATE b, FILE *file ));

#define ps_new_buffer ps_create_buffer

#ifdef __cplusplus
static int psinput ps_PROTO(( void ));
#else
static int input ps_PROTO(( void ));
#endif

ps_DECL
    {
    register ps_state_type ps_current_state;
    register ps_CHAR *ps_cp, *ps_bp;
    register int ps_act;




    if ( ps_init )
	{
	ps_USER_INIT;

	if ( ! ps_start )
	    ps_start = 1;	/* first start state */

	if ( ! psin )
	    psin = stdin;

	if ( ! psout )
	    psout = stdout;

	if ( ps_current_buffer )
	    ps_init_buffer( ps_current_buffer, psin );
	else
	    ps_current_buffer = ps_create_buffer( psin, ps_BUF_SIZE );

	ps_load_buffer_state();

	ps_init = 0;
	}

    while ( 1 )		/* loops until end-of-file is reached */
	{
	ps_cp = ps_c_buf_p;

	/* support of pstext */
	*ps_cp = ps_hold_char;

	/* ps_bp points to the position in ps_ch_buf of the start of the
	 * current run.
	 */
	ps_bp = ps_cp;

	ps_current_state = ps_start;
ps_match:
	do
	    {
	    register ps_CHAR ps_c = ps_ec[*ps_cp];
	    if ( ps_accept[ps_current_state] )
		{
		ps_last_accepting_state = ps_current_state;
		ps_last_accepting_cpos = ps_cp;
		}
	    while ( ps_chk[ps_base[ps_current_state] + ps_c] != ps_current_state )
		{
		ps_current_state = ps_def[ps_current_state];
		if ( ps_current_state >= 6 )
		    ps_c = ps_meta[ps_c];
		}
	    ps_current_state = ps_nxt[ps_base[ps_current_state] + ps_c];
	    ++ps_cp;
	    }
	while ( ps_current_state != 5 );
	ps_cp = ps_last_accepting_cpos;
	ps_current_state = ps_last_accepting_state;

ps_find_action:
	ps_act = ps_accept[ps_current_state];

	ps_DO_BEFORE_ACTION;
	ps_USER_ACTION;

do_action:	/* this label is used only to access EOF actions */


	switch ( ps_act )
	    {
	    case 0: /* must backtrack */
	    /* undo the effects of ps_DO_BEFORE_ACTION */
	    *ps_cp = ps_hold_char;
	    ps_cp = ps_last_accepting_cpos;
	    ps_current_state = ps_last_accepting_state;
	    goto ps_find_action;

case 1:
# line 59 "ps.l"
{
	   if ( psbuffed >= psbuf_sz ) {
              //alphabet -> add_letters( psbuf, psbuf_sz );
              (*lex_action_func)(psbuf, psbuf_sz, 2);
              psbuffed = 0;
           }

           psbuf[psbuffed++] = pstext[0];
	}
	ps_BREAK
case 2:
# line 70 "ps.l"
ps_FATAL_ERROR( "flex scanner jammed" );
	ps_BREAK
case ps_STATE_EOF(INITIAL):
    psterminate();

	    case ps_END_OF_BUFFER:
		{
		/* amount of text matched not including the EOB char */
		int ps_amount_of_matched_text = ps_cp - pstext - 1;

		/* undo the effects of ps_DO_BEFORE_ACTION */
		*ps_cp = ps_hold_char;

		/* note that here we test for ps_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since ps_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the end-
		 * of-buffer state).  Contrast this with the test in psinput().
		 */
		if ( ps_c_buf_p <= &ps_current_buffer->ps_ch_buf[ps_n_chars] )
		    /* this was really a NUL */
		    {
		    ps_state_type ps_next_state;

		    ps_c_buf_p = pstext + ps_amount_of_matched_text;

		    ps_current_state = ps_get_previous_state();

		    /* okay, we're now positioned to make the
		     * NUL transition.  We couldn't have
		     * ps_get_previous_state() go ahead and do it
		     * for us because it doesn't know how to deal
		     * with the possibility of jamming (and we
		     * don't want to build jamming into it because
		     * then it will run more slowly)
		     */

		    ps_next_state = ps_try_NUL_trans( ps_current_state );

		    ps_bp = pstext + ps_MORE_ADJ;

		    if ( ps_next_state )
			{
			/* consume the NUL */
			ps_cp = ++ps_c_buf_p;
			ps_current_state = ps_next_state;
			goto ps_match;
			}

		    else
			{
			    ps_cp = ps_last_accepting_cpos;
			    ps_current_state = ps_last_accepting_state;
			goto ps_find_action;
			}
		    }

		else switch ( ps_get_next_buffer() )
		    {
		    case EOB_ACT_END_OF_FILE:
			{
			ps_did_buffer_switch_on_eof = 0;

			if ( pswrap() )
			    {
			    /* note: because we've taken care in
			     * ps_get_next_buffer() to have set up pstext,
			     * we can now set up ps_c_buf_p so that if some
			     * total hoser (like flex itself) wants
			     * to call the scanner after we return the
			     * ps_NULL, it'll still work - another ps_NULL
			     * will get returned.
			     */
			    ps_c_buf_p = pstext + ps_MORE_ADJ;

			    ps_act = ps_STATE_EOF((ps_start - 1) / 2);
			    goto do_action;
			    }

			else
			    {
			    if ( ! ps_did_buffer_switch_on_eof )
				ps_NEW_FILE;
			    }
			}
			break;

		    case EOB_ACT_CONTINUE_SCAN:
			ps_c_buf_p = pstext + ps_amount_of_matched_text;

			ps_current_state = ps_get_previous_state();

			ps_cp = ps_c_buf_p;
			ps_bp = pstext + ps_MORE_ADJ;
			goto ps_match;

		    case EOB_ACT_LAST_MATCH:
			ps_c_buf_p =
			    &ps_current_buffer->ps_ch_buf[ps_n_chars];

			ps_current_state = ps_get_previous_state();

			ps_cp = ps_c_buf_p;
			ps_bp = pstext + ps_MORE_ADJ;
			goto ps_find_action;
		    }
		break;
		}

	    default:
#ifdef FLEX_DEBUG
		printf( "action # %d\n", ps_act );
#endif
		ps_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	    }
	}
    }


/* ps_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int ps_get_next_buffer();
 *     
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH - 
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */

static int ps_get_next_buffer()

    {
    register ps_CHAR *dest = ps_current_buffer->ps_ch_buf;
    register ps_CHAR *source = pstext - 1; /* copy prev. char, too */
    register int number_to_move, i;
    int ret_val;

    if ( ps_c_buf_p > &ps_current_buffer->ps_ch_buf[ps_n_chars + 1] )
	ps_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

    /* try to read more data */

    /* first move last chars to start of buffer */
    number_to_move = ps_c_buf_p - pstext;

    for ( i = 0; i < number_to_move; ++i )
	*(dest++) = *(source++);

    if ( ps_current_buffer->ps_eof_status != EOF_NOT_SEEN )
	/* don't do the read, it's not guaranteed to return an EOF,
	 * just force an EOF
	 */
	ps_n_chars = 0;

    else
	{
	int num_to_read = ps_current_buffer->ps_buf_size - number_to_move - 1;

	if ( num_to_read > ps_READ_BUF_SIZE )
	    num_to_read = ps_READ_BUF_SIZE;

	else if ( num_to_read <= 0 )
	    ps_FATAL_ERROR( "fatal error - scanner input buffer overflow" );

	/* read in more data */
	ps_INPUT( (&ps_current_buffer->ps_ch_buf[number_to_move]),
		  ps_n_chars, num_to_read );
	}

    if ( ps_n_chars == 0 )
	{
	if ( number_to_move == 1 )
	    {
	    ret_val = EOB_ACT_END_OF_FILE;
	    ps_current_buffer->ps_eof_status = EOF_DONE;
	    }

	else
	    {
	    ret_val = EOB_ACT_LAST_MATCH;
	    ps_current_buffer->ps_eof_status = EOF_PENDING;
	    }
	}

    else
	ret_val = EOB_ACT_CONTINUE_SCAN;

    ps_n_chars += number_to_move;
    ps_current_buffer->ps_ch_buf[ps_n_chars] = ps_END_OF_BUFFER_CHAR;
    ps_current_buffer->ps_ch_buf[ps_n_chars + 1] = ps_END_OF_BUFFER_CHAR;

    /* pstext begins at the second character in ps_ch_buf; the first
     * character is the one which preceded it before reading in the latest
     * buffer; it needs to be kept around in case it's a newline, so
     * ps_get_previous_state() will have with '^' rules active
     */

    pstext = &ps_current_buffer->ps_ch_buf[1];

    return ( ret_val );
    }


/* ps_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     ps_state_type ps_get_previous_state();
 */

static ps_state_type ps_get_previous_state()

    {
    register ps_state_type ps_current_state;
    register ps_CHAR *ps_cp;

    ps_current_state = ps_start;

    for ( ps_cp = pstext + ps_MORE_ADJ; ps_cp < ps_c_buf_p; ++ps_cp )
	{
	register ps_CHAR ps_c = (*ps_cp ? ps_ec[*ps_cp] : 1);
	if ( ps_accept[ps_current_state] )
	    {
	    ps_last_accepting_state = ps_current_state;
	    ps_last_accepting_cpos = ps_cp;
	    }
	while ( ps_chk[ps_base[ps_current_state] + ps_c] != ps_current_state )
	    {
	    ps_current_state = ps_def[ps_current_state];
	    if ( ps_current_state >= 6 )
		ps_c = ps_meta[ps_c];
	    }
	ps_current_state = ps_nxt[ps_base[ps_current_state] + ps_c];
	}

    return ( ps_current_state );
    }


/* ps_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state = ps_try_NUL_trans( current_state );
 */

#ifdef ps_USE_PROTOS
static ps_state_type ps_try_NUL_trans( register ps_state_type ps_current_state )
#else
static ps_state_type ps_try_NUL_trans( ps_current_state )
register ps_state_type ps_current_state;
#endif

    {
    register int ps_is_jam;
    register ps_CHAR *ps_cp = ps_c_buf_p;

    register ps_CHAR ps_c = 1;
    if ( ps_accept[ps_current_state] )
	{
	ps_last_accepting_state = ps_current_state;
	ps_last_accepting_cpos = ps_cp;
	}
    while ( ps_chk[ps_base[ps_current_state] + ps_c] != ps_current_state )
	{
	ps_current_state = ps_def[ps_current_state];
	if ( ps_current_state >= 6 )
	    ps_c = ps_meta[ps_c];
	}
    ps_current_state = ps_nxt[ps_base[ps_current_state] + ps_c];
    ps_is_jam = (ps_current_state == 5);

    return ( ps_is_jam ? 0 : ps_current_state );
    }


#ifdef ps_USE_PROTOS
static void psunput( ps_CHAR c, register ps_CHAR *ps_bp )
#else
static void psunput( c, ps_bp )
ps_CHAR c;
register ps_CHAR *ps_bp;
#endif

    {
    register ps_CHAR *ps_cp = ps_c_buf_p;

    /* undo effects of setting up pstext */
    *ps_cp = ps_hold_char;

    if ( ps_cp < ps_current_buffer->ps_ch_buf + 2 )
	{ /* need to shift things up to make room */
	register int number_to_move = ps_n_chars + 2; /* +2 for EOB chars */
	register ps_CHAR *dest =
	    &ps_current_buffer->ps_ch_buf[ps_current_buffer->ps_buf_size + 2];
	register ps_CHAR *source =
	    &ps_current_buffer->ps_ch_buf[number_to_move];

	while ( source > ps_current_buffer->ps_ch_buf )
	    *--dest = *--source;

	ps_cp += dest - source;
	ps_bp += dest - source;
	ps_n_chars = ps_current_buffer->ps_buf_size;

	if ( ps_cp < ps_current_buffer->ps_ch_buf + 2 )
	    ps_FATAL_ERROR( "flex scanner push-back overflow" );
	}

    if ( ps_cp > ps_bp && ps_cp[-1] == '\n' )
	ps_cp[-2] = '\n';

    *--ps_cp = c;

    /* note: the formal parameter *must* be called "ps_bp" for this
     *       macro to now work correctly
     */
    ps_DO_BEFORE_ACTION; /* set up pstext again */
    }


#ifdef __cplusplus
static int psinput()
#else
static int input()
#endif

    {
    int c;
    ps_CHAR *ps_cp = ps_c_buf_p;

    *ps_cp = ps_hold_char;

    if ( *ps_c_buf_p == ps_END_OF_BUFFER_CHAR )
	{
	/* ps_c_buf_p now points to the character we want to return.
	 * If this occurs *before* the EOB characters, then it's a
	 * valid NUL; if not, then we've hit the end of the buffer.
	 */
	if ( ps_c_buf_p < &ps_current_buffer->ps_ch_buf[ps_n_chars] )
	    /* this was really a NUL */
	    *ps_c_buf_p = '\0';

	else
	    { /* need more input */
	    pstext = ps_c_buf_p;
	    ++ps_c_buf_p;

	    switch ( ps_get_next_buffer() )
		{
		case EOB_ACT_END_OF_FILE:
		    {
		    if ( pswrap() )
			{
			ps_c_buf_p = pstext + ps_MORE_ADJ;
			return ( EOF );
			}

		    ps_NEW_FILE;

#ifdef __cplusplus
		    return ( psinput() );
#else
		    return ( input() );
#endif
		    }
		    break;

		case EOB_ACT_CONTINUE_SCAN:
		    ps_c_buf_p = pstext + ps_MORE_ADJ;
		    break;

		case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
		    ps_FATAL_ERROR( "unexpected last match in psinput()" );
#else
		    ps_FATAL_ERROR( "unexpected last match in input()" );
#endif
		}
	    }
	}

    c = *ps_c_buf_p;
    ps_hold_char = *++ps_c_buf_p;

    return ( c );
    }


#ifdef ps_USE_PROTOS
void psrestart( FILE *input_file )
#else
void psrestart( input_file )
FILE *input_file;
#endif

    {
    ps_init_buffer( ps_current_buffer, input_file );
    ps_load_buffer_state();
    }


#ifdef ps_USE_PROTOS
void ps_switch_to_buffer( ps_BUFFER_STATE new_buffer )
#else
void ps_switch_to_buffer( new_buffer )
ps_BUFFER_STATE new_buffer;
#endif

    {
    if ( ps_current_buffer == new_buffer )
	return;

    if ( ps_current_buffer )
	{
	/* flush out information for old buffer */
	*ps_c_buf_p = ps_hold_char;
	ps_current_buffer->ps_buf_pos = ps_c_buf_p;
	ps_current_buffer->ps_n_chars = ps_n_chars;
	}

    ps_current_buffer = new_buffer;
    ps_load_buffer_state();

    /* we don't actually know whether we did this switch during
     * EOF (pswrap()) processing, but the only time this flag
     * is looked at is after pswrap() is called, so it's safe
     * to go ahead and always set it.
     */
    ps_did_buffer_switch_on_eof = 1;
    }


#ifdef ps_USE_PROTOS
void ps_load_buffer_state( void )
#else
void ps_load_buffer_state()
#endif

    {
    ps_n_chars = ps_current_buffer->ps_n_chars;
    pstext = ps_c_buf_p = ps_current_buffer->ps_buf_pos;
    psin = ps_current_buffer->ps_input_file;
    ps_hold_char = *ps_c_buf_p;
    }


#ifdef ps_USE_PROTOS
ps_BUFFER_STATE ps_create_buffer( FILE *file, int size )
#else
ps_BUFFER_STATE ps_create_buffer( file, size )
FILE *file;
int size;
#endif

    {
    ps_BUFFER_STATE b;

    b = (ps_BUFFER_STATE) malloc( sizeof( struct ps_buffer_state ) );

    if ( ! b )
	ps_FATAL_ERROR( "out of dynamic memory in ps_create_buffer()" );

    b->ps_buf_size = size;

    /* ps_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->ps_ch_buf = (ps_CHAR *) malloc( (unsigned) (b->ps_buf_size + 2) );

    if ( ! b->ps_ch_buf )
	ps_FATAL_ERROR( "out of dynamic memory in ps_create_buffer()" );

    ps_init_buffer( b, file );

    return ( b );
    }


#ifdef ps_USE_PROTOS
void ps_delete_buffer( ps_BUFFER_STATE b )
#else
void ps_delete_buffer( b )
ps_BUFFER_STATE b;
#endif

    {
    if ( b == ps_current_buffer )
	ps_current_buffer = (ps_BUFFER_STATE) 0;

    free( (char *) b->ps_ch_buf );
    free( (char *) b );
    }


#ifdef ps_USE_PROTOS
void ps_init_buffer( ps_BUFFER_STATE b, FILE *file )
#else
void ps_init_buffer( b, file )
ps_BUFFER_STATE b;
FILE *file;
#endif

    {
    b->ps_input_file = file;

    /* we put in the '\n' and start reading from [1] so that an
     * initial match-at-newline will be true.
     */

    b->ps_ch_buf[0] = '\n';
    b->ps_n_chars = 1;

    /* we always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->ps_ch_buf[1] = ps_END_OF_BUFFER_CHAR;
    b->ps_ch_buf[2] = ps_END_OF_BUFFER_CHAR;

    b->ps_buf_pos = &b->ps_ch_buf[1];

    b->ps_eof_status = EOF_NOT_SEEN;
    }
# line 70 "ps.l"


int pswrap()
{
   //alphabet -> add_letters( psbuf, psbuffed );
   (*lex_action_func)(psbuf, psbuffed, 2);
   return 1;
}

