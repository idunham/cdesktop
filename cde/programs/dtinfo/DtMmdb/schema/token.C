/*
 * CDE - Common Desktop Environment
 *
 * Copyright (c) 1993-2012, The Open Group. All rights reserved.
 *
 * These libraries and programs are free software; you can
 * redistribute them and/or modify them under the terms of the GNU
 * Lesser General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * These libraries and programs are distributed in the hope that
 * they will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with these librararies and programs; if not, write
 * to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
 * Floor, Boston, MA 02110-1301 USA
 */
/* A lexical scanner generated by flex */

/* scanner skeleton version:
 * $XConsortium: token.cc /main/4 1996/07/05 15:20:12 rws $
 */

#define FLEX_SCANNER

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>

#if defined(__osf__) || defined(linux) || defined(CSRG_BASED)
#include <unistd.h>
#else
#if !defined(__uxp__) && !defined(USL)
#include <osfcn.h>
#endif
#endif

/* use prototypes in function declarations */
#define  schema_USE_PROTOS

/* the "const" storage-class-modifier is valid */
#define  schema_USE_CONST

#else	/* ! __cplusplus */

#ifdef __STDC__

#ifdef __GNUC__
#include <stddef.h>
void *malloc( size_t );
void free( void* );
#else
#include <stdlib.h>
#endif	/* __GNUC__ */

#define  schema_USE_PROTOS
#define  schema_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */


#ifdef __TURBOC__
#define  schema_USE_CONST
#endif


#ifndef  schema_USE_CONST
#define const
#endif


#ifdef  schema_USE_PROTOS
#define  schema_PROTO(proto) proto
#else
#define  schema_PROTO(proto) ()
/* we can't get here if it's an ANSI C compiler, or a C++ compiler,
 * so it's got to be a K&R compiler, and therefore there's no standard
 * place from which to include these definitions
 */
char *malloc();
int free();
int read();
#endif


/* amount of stuff to slurp up with each read */
#ifndef  schema_READ_BUF_SIZE
#define  schema_READ_BUF_SIZE 8192
#endif

/* returned upon end-of-file */
#define  schema_END_TOK 0

/* copy whatever the last rule matched to the standard output */

/* cast to (char *) is because for 8-bit chars,  schematext is (unsigned char *) */
/* this used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite()
 */
#define ECHO (void) fwrite( (char *)  schematext,  schemaleng, 1,  schemaout )

/* gets input and stuffs it into "buf".  number of characters read, or  schema_NULL,
 * is returned in "result".
 */
#define  schema_INPUT(buf,result,max_size) \
	if ( (result = read( fileno( schemain), (char *) buf, max_size )) < 0 ) \
	     schema_FATAL_ERROR( "read() in flex scanner failed" );
#define  schema_NULL 0

/* no semi-colon after return; correct usage is to write " schematerminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#define  schematerminate() return (  schema_NULL )

/* report a fatal error */

/* The funky do-while is used to turn this macro definition into
 * a single C statement (which needs a semi-colon terminator).
 * This avoids problems with code like:
 *
 * 	if ( something_happens )
 *		 schema_FATAL_ERROR( "oops, the something happened" );
 *	else
 *		everything_okay();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the  schema_FATAL_ERROR() call.
 */

#define  schema_FATAL_ERROR(msg) \
	do \
		{ \
		(void) fputs( msg, stderr ); \
		(void) putc( '\n', stderr ); \
		exit( 1 ); \
		} \
	while ( 0 )

/* default  schemawrap function - always treat EOF as an EOF */
#define  schemawrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN  schema_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define  schema_STATE_EOF(state) ( schema_END_OF_BUFFER + state + 1)

/* special action meaning "start processing a new file" */
#define  schema_NEW_FILE \
	do \
		{ \
		 schema_init_buffer(  schema_current_buffer,  schemain ); \
		 schema_load_buffer_state(); \
		} \
	while ( 0 )

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define  schema_DECL int  schemalex  schema_PROTO(( void )) 

/* code executed at the end of each rule */
#define  schema_BREAK break;

#define  schema_END_OF_BUFFER_CHAR 0

#ifndef  schema_BUF_SIZE
#define  schema_BUF_SIZE ( schema_READ_BUF_SIZE * 2) /* size of default input buffer */
#endif

typedef struct  schema_buffer_state * schema_BUFFER_STATE;

#define  schema_CHAR unsigned char
#define INITIAL 0
/*
* $XConsortium: token.cc /main/4 1996/07/05 15:20:12 rws $
*
* Copyright (c) 1993 HAL Computer Systems International, Ltd.
* All rights reserved.  Unpublished -- rights reserved under
* the Copyright Laws of the United States.  USE OF A COPYRIGHT
* NOTICE IS PRECAUTIONARY ONLY AND DOES NOT IMPLY PUBLICATION
* OR DISCLOSURE.
* 
* THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE
* SECRETS OF HAL COMPUTER SYSTEMS INTERNATIONAL, LTD.  USE,
* DISCLOSURE, OR REPRODUCTION IS PROHIBITED WITHOUT THE
* PRIOR EXPRESS WRITTEN PERMISSION OF HAL COMPUTER SYSTEMS
* INTERNATIONAL, LTD.
* 
*                         RESTRICTED RIGHTS LEGEND
* Use, duplication, or disclosure by the Government is subject
* to the restrictions as set forth in subparagraph (c)(l)(ii)
* of the Rights in Technical Data and Computer Software clause
* at DFARS 252.227-7013.
*
*          HAL COMPUTER SYSTEMS INTERNATIONAL, LTD.
*                  1315 Dell Avenue
*                  Campbell, CA  95008
* 
*/
#include "store_desc.h"
#include "sheet.tab.h"
extern char replace_string[PATHSIZ];
extern int replace_string_len;

int linecount = 1;

/* done after the current pattern has been matched and before the
 * corresponding action - sets up  schematext
 */
#define  schema_DO_BEFORE_ACTION \
	 schematext =  schema_bp; \
	 schemaleng =  schema_cp -  schema_bp; \
	 schema_hold_char = * schema_cp; \
	* schema_cp = '\0'; \
	 schema_c_buf_p =  schema_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define  schemaless(n) \
	do \
		{ \
		/* undo effects of setting up  schematext */ \
		* schema_cp =  schema_hold_char; \
		 schema_c_buf_p =  schema_cp =  schema_bp + n; \
		 schema_DO_BEFORE_ACTION; /* set up  schematext again */ \
		} \
	while ( 0 )

#define unput(c)  schemaunput( c,  schematext )


struct  schema_buffer_state
    {
    FILE * schema_input_file;

     schema_CHAR * schema_ch_buf;		/* input buffer */
     schema_CHAR * schema_buf_pos;	/* current position in input buffer */

    /* size of input buffer in bytes, not including room for EOB characters*/
    int  schema_buf_size;	

    /* number of characters read into  schema_ch_buf, not including EOB characters */
    int  schema_n_chars;

    int  schema_eof_status;		/* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
    /* "pending" happens when the EOF has been seen but there's still
     * some text process
     */
#define EOF_PENDING 1
#define EOF_DONE 2
    };

static  schema_BUFFER_STATE  schema_current_buffer;

/* we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */
#define  schema_CURRENT_BUFFER  schema_current_buffer


/*  schema_hold_char holds the character lost when  schematext is formed */
static  schema_CHAR  schema_hold_char;

static int  schema_n_chars;		/* number of characters read into  schema_ch_buf */



#ifndef  schema_USER_ACTION
#define  schema_USER_ACTION
#endif

#ifndef  schema_USER_INIT
#define  schema_USER_INIT
#endif

extern  schema_CHAR * schematext;
extern int  schemaleng;
extern FILE * schemain, * schemaout;

 schema_CHAR * schematext;
int  schemaleng;

FILE * schemain = (FILE *) 0, * schemaout = (FILE *) 0;

#define  schema_END_OF_BUFFER 37
typedef int  schema_state_type;
static const short int  schema_accept[164] =
    {   0,
        0,    0,   37,   36,   32,   31,   35,   34,   30,   29,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   33,   32,   31,   35,   34,   30,   30,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       23,   35,   35,   35,   35,   35,   35,   33,   35,   35,
       35,   35,   35,   35,   35,   35,   35,    5,   35,   35,
       35,   35,   35,    2,   35,   35,   35,   35,   35,   35,
       35,   35,   35,    8,   35,   35,   35,    3,   25,   10,
       35,   35,   35,   35,   35,   35,   11,   35,   35,   35,
       35,   35,   13,   35,   35,   35,   35,   12,   21,   24,

       35,   35,   35,   35,   35,   35,   35,   35,   17,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
        7,   35,   35,   35,   35,   26,   35,   35,   35,   18,
       35,   35,   35,    6,   35,   35,    4,   35,   35,   20,
       35,   19,   35,   35,   35,    1,   35,   35,   35,   35,
       35,   27,   35,   35,   14,   22,   35,   16,   35,    9,
       15,   28,    0
    } ;

static const  schema_CHAR  schema_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    1,    4,    5,    1,    1,    1,    1,
        1,    1,    1,    1,    5,    5,    1,    6,    6,    6,
        6,    6,    6,    6,    6,    6,    6,    7,    1,    1,
        8,    1,    1,    1,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        1,    9,    1,    1,   10,    1,   11,   12,   13,   14,

       15,   16,   17,   18,   19,    5,    5,   20,   21,   22,
       23,   24,    5,   25,   26,   27,   28,   29,    5,   30,
       31,   32,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const  schema_CHAR  schema_meta[33] =
    {   0,
        1,    1,    2,    1,    3,    3,    1,    1,    1,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3
    } ;

static const short int  schema_base[166] =
    {   0,
        0,  174,  177,  179,  174,  172,    0,  168,   30,  179,
      156,    7,   24,  153,  143,  148,  150,   13,  147,   29,
       27,  157,    0,  164,  162,    0,  158,  179,  160,  147,
      136,  133,  146,   22,  145,  141,   27,  130,  141,  136,
        0,  136,  126,  124,  126,  126,  125,    0,  125,  131,
      130,  126,  119,  115,  114,  124,  124,  128,  110,  121,
      119,  119,  114,    0,  114,  106,  111,  102,  113,  117,
      111,  100,  113,    0,  102,   92,   99,    0,    0,  110,
      109,   91,  101,  101,  101,  104,  103,   89,   97,   95,
       90,   97,   97,   85,   86,   78,   84,   92,   91,    0,

       78,   80,   73,   87,   70,   73,   72,   35,    0,   71,
       18,   69,   72,   68,   68,   66,   73,   62,   59,   69,
        0,   66,   61,   67,   57,    0,   57,   56,   56,    0,
       62,   60,   63,    0,   48,   57,    0,   56,   45,    0,
       55,    0,   53,   42,   49,    0,   43,   34,   48,   47,
       31,    0,   44,   28,    0,    0,   23,    0,   25,    0,
        0,    0,  179,   46,   57
    } ;

static const short int  schema_def[166] =
    {   0,
      163,    1,  163,  163,  163,  163,  164,  164,  163,  163,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  165,  163,  163,  164,  164,  163,  163,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  165,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,

      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,  164,  164,  164,  164,  164,  164,  164,  164,
      164,  164,    0,  163,  163
    } ;

static const short int  schema_nxt[212] =
    {   0,
        4,    5,    6,    4,    7,    8,    9,   10,    4,    7,
       11,   12,   13,   14,    7,    7,    7,   15,   16,   17,
       18,   19,    7,   20,    7,   21,    7,    7,   22,    7,
        7,    7,   28,   31,   33,   39,   40,   32,   29,   42,
       57,   44,   53,   54,  125,  122,   34,   45,   26,  126,
      162,   43,  161,   46,  160,   58,  123,   48,  159,   48,
      158,  157,  156,  155,  154,  153,  152,  151,  150,  149,
      148,  147,  146,  145,  144,  143,  142,  141,  140,  139,
      138,  137,  136,  135,  134,  133,  132,  131,  130,  129,
      128,  127,  124,  121,  120,  119,  118,  117,  116,  115,

      114,  113,  112,  111,  110,  109,  108,  107,  106,  105,
      104,  103,  102,  101,  100,   99,   98,   97,   96,   95,
       94,   93,   92,   91,   90,   89,   88,   87,   86,   85,
       84,   83,   82,   81,   80,   79,   78,   77,   76,   75,
       74,   73,   72,   71,   70,   69,   68,   67,   66,   65,
       64,   63,   62,   61,   60,   59,   56,   55,   52,   51,
       50,   49,   28,   27,   25,   24,   47,   41,   38,   37,
       36,   35,   30,   27,   25,   24,  163,   23,    3,  163,
      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,

      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
      163
    } ;

static const short int  schema_chk[212] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    9,   12,   13,   18,   18,   12,    9,   20,
       37,   21,   34,   34,  111,  108,   13,   21,  164,  111,
      159,   20,  157,   21,  154,   37,  108,  165,  153,  165,
      151,  150,  149,  148,  147,  145,  144,  143,  141,  139,
      138,  136,  135,  133,  132,  131,  129,  128,  127,  125,
      124,  123,  122,  120,  119,  118,  117,  116,  115,  114,
      113,  112,  110,  107,  106,  105,  104,  103,  102,  101,

       99,   98,   97,   96,   95,   94,   93,   92,   91,   90,
       89,   88,   87,   86,   85,   84,   83,   82,   81,   80,
       77,   76,   75,   73,   72,   71,   70,   69,   68,   67,
       66,   65,   63,   62,   61,   60,   59,   58,   57,   56,
       55,   54,   53,   52,   51,   50,   49,   47,   46,   45,
       44,   43,   42,   40,   39,   38,   36,   35,   33,   32,
       31,   30,   29,   27,   25,   24,   22,   19,   17,   16,
       15,   14,   11,    8,    6,    5,    3,    2,  163,  163,
      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,

      163,  163,  163,  163,  163,  163,  163,  163,  163,  163,
      163
    } ;

static  schema_state_type  schema_last_accepting_state;
static  schema_CHAR * schema_last_accepting_cpos;

/* the intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed
 */
#define REJECT reject_used_but_not_detected
#define  schemamore()  schemamore_used_but_not_detected
#define  schema_MORE_ADJ 0

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
/* points to current character in buffer */
static  schema_CHAR * schema_c_buf_p = ( schema_CHAR *) 0;
static int  schema_init = 1;		/* whether we need to initialize */
static int  schema_start = 0;	/* start state number */

/* flag which is used to allow  schemawrap()'s to do buffer switches
 * instead of setting up a fresh  schemain.  A bit of a hack ...
 */
static int  schema_did_buffer_switch_on_eof;

static  schema_state_type  schema_get_previous_state  schema_PROTO(( void ));
static  schema_state_type  schema_try_NUL_trans  schema_PROTO((  schema_state_type current_state ));
static int  schema_get_next_buffer  schema_PROTO(( void ));
static void  schemaunput  schema_PROTO((  schema_CHAR c,  schema_CHAR *buf_ptr ));
void  schemarestart  schema_PROTO(( FILE *input_file ));
void  schema_switch_to_buffer  schema_PROTO((  schema_BUFFER_STATE new_buffer ));
void  schema_load_buffer_state  schema_PROTO(( void ));
 schema_BUFFER_STATE  schema_create_buffer  schema_PROTO(( FILE *file, int size ));
void  schema_delete_buffer  schema_PROTO((  schema_BUFFER_STATE b ));
void  schema_init_buffer  schema_PROTO((  schema_BUFFER_STATE b, FILE *file ));

#define  schema_new_buffer  schema_create_buffer

#ifdef __cplusplus
static int  schemainput  schema_PROTO(( void ));
#else
static int input  schema_PROTO(( void ));
#endif

 schema_DECL
    {
    register  schema_state_type  schema_current_state;
    register  schema_CHAR * schema_cp, * schema_bp;
    register int  schema_act;




    if (  schema_init )
	{
	 schema_USER_INIT;

	if ( !  schema_start )
	     schema_start = 1;	/* first start state */

	if ( !  schemain )
	     schemain = stdin;

	if ( !  schemaout )
	     schemaout = stdout;

	if (  schema_current_buffer )
	     schema_init_buffer(  schema_current_buffer,  schemain );
	else
	     schema_current_buffer =  schema_create_buffer(  schemain,  schema_BUF_SIZE );

	 schema_load_buffer_state();

	 schema_init = 0;
	}

    while ( 1 )		/* loops until end-of-file is reached */
	{
	 schema_cp =  schema_c_buf_p;

	/* support of  schematext */
	* schema_cp =  schema_hold_char;

	/*  schema_bp points to the position in  schema_ch_buf of the start of the
	 * current run.
	 */
	 schema_bp =  schema_cp;

	 schema_current_state =  schema_start;
	if (  schema_bp[-1] == '\n' )
	    ++ schema_current_state;
 schema_match:
	do
	    {
	    register  schema_CHAR  schema_c =  schema_ec[* schema_cp];
	    if (  schema_accept[ schema_current_state] )
		{
		 schema_last_accepting_state =  schema_current_state;
		 schema_last_accepting_cpos =  schema_cp;
		}
	    while (  schema_chk[ schema_base[ schema_current_state] +  schema_c] !=  schema_current_state )
		{
		 schema_current_state =  schema_def[ schema_current_state];
		if (  schema_current_state >= 164 )
		     schema_c =  schema_meta[ schema_c];
		}
	     schema_current_state =  schema_nxt[ schema_base[ schema_current_state] +  schema_c];
	    ++ schema_cp;
	    }
	while (  schema_current_state != 163 );
	 schema_cp =  schema_last_accepting_cpos;
	 schema_current_state =  schema_last_accepting_state;

 schema_find_action:
	 schema_act =  schema_accept[ schema_current_state];

	 schema_DO_BEFORE_ACTION;
	 schema_USER_ACTION;

do_action:	/* this label is used only to access EOF actions */


	switch (  schema_act )
	    {
	    case 0: /* must backtrack */
	    /* undo the effects of  schema_DO_BEFORE_ACTION */
	    * schema_cp =  schema_hold_char;
	     schema_cp =  schema_last_accepting_cpos;
	     schema_current_state =  schema_last_accepting_state;
	    goto  schema_find_action;

case 1:
{
         return(CONTAINER);
        }
	 schema_BREAK
case 2:
{
         return(SET);
        }
	 schema_BREAK
case 3:
{
         return(LIST);
        }
	 schema_BREAK
case 4:
{
         return(INDEX_NAME);
        }
	 schema_BREAK
case 5:
{
         return(INV);
        }
	 schema_BREAK
case 6:
{
         return(COMPRESS);
        }
	 schema_BREAK
case 7:
{
         return(HUFFMAN);
        }
	 schema_BREAK
case 8:
{
         return(DICT);
        }
	 schema_BREAK
case 9:
{
         return(INDEX_AGENT);
        }
	 schema_BREAK
case 10:
{
         return(MPHF);
        }
	 schema_BREAK
case 11:
{
         return(BTREE);
        }
	 schema_BREAK
case 12:
{
         return(SMPHF);
        }
	 schema_BREAK
case 13:
{
         return(INDEX);
        }
	 schema_BREAK
case 14:
{
         return(MPHF_INDEX);
        }
	 schema_BREAK
case 15:
{
         return(SMPHF_INDEX);
        }
	 schema_BREAK
case 16:
{
         return(BTREE_INDEX);
        }
	 schema_BREAK
case 17:
{
         return(INV_NAME);
        }
	 schema_BREAK
case 18:
{
         return(AGENT_NAME);
        }
	 schema_BREAK
case 19:
{
         return(STORE_NAME);
        }
	 schema_BREAK
case 20:
{
         return(POSITION);
        }
	 schema_BREAK
case 21:
{
         return(STORE);
        }
	 schema_BREAK
case 22:
{
         return(PAGE_STORE);
        }
	 schema_BREAK
case 23:
{
         return(NM);
        }
	 schema_BREAK
case 24:
{
         return(V_OID);
        }
	 schema_BREAK
case 25:
{
         return(MODE);
        }
	 schema_BREAK
case 26:
{
         return(PAGE_SZ);
        }
	 schema_BREAK
case 27:
{
         return(BYTE_ORDER);
        }
	 schema_BREAK
case 28:
{
         return(CACHED_PAGES);
        }
	 schema_BREAK
case 29:
{
         return(EQUAL);
	}
	 schema_BREAK
case 30:
{
         return(SEPARATOR);
	}
	 schema_BREAK
case 31:
{ 
	   linecount++; 
	 }
	 schema_BREAK
case 32:
{
	}
	 schema_BREAK
case 33:
{
	}
	 schema_BREAK
case 34:
{
    	  schemalval.integer = atoi((char*) schematext);
         return (NUMBER);
	}
	 schema_BREAK
case 35:
{
         if ( replace_string[0] != 0 &&  schematext[0] == '$' ) {
            strcpy(replace_string + replace_string_len, (char*) schematext+1);
    	     schemalval.string = replace_string;
         } else
    	     schemalval.string = (char*) schematext;
         return (TOKEN);
	}
	 schema_BREAK
case 36:
 schema_FATAL_ERROR( "flex scanner jammed" );
	 schema_BREAK
case  schema_STATE_EOF(INITIAL):
     schematerminate();

	    case  schema_END_OF_BUFFER:
		{
		/* amount of text matched not including the EOB char */
		int  schema_amount_of_matched_text =  schema_cp -  schematext - 1;

		/* undo the effects of  schema_DO_BEFORE_ACTION */
		* schema_cp =  schema_hold_char;

		/* note that here we test for  schema_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since  schema_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the end-
		 * of-buffer state).  Contrast this with the test in  schemainput().
		 */
		if (  schema_c_buf_p <= & schema_current_buffer-> schema_ch_buf[ schema_n_chars] )
		    /* this was really a NUL */
		    {
		     schema_state_type  schema_next_state;

		     schema_c_buf_p =  schematext +  schema_amount_of_matched_text;

		     schema_current_state =  schema_get_previous_state();

		    /* okay, we're now positioned to make the
		     * NUL transition.  We couldn't have
		     *  schema_get_previous_state() go ahead and do it
		     * for us because it doesn't know how to deal
		     * with the possibility of jamming (and we
		     * don't want to build jamming into it because
		     * then it will run more slowly)
		     */

		     schema_next_state =  schema_try_NUL_trans(  schema_current_state );

		     schema_bp =  schematext +  schema_MORE_ADJ;

		    if (  schema_next_state )
			{
			/* consume the NUL */
			 schema_cp = ++ schema_c_buf_p;
			 schema_current_state =  schema_next_state;
			goto  schema_match;
			}

		    else
			{
			     schema_cp =  schema_last_accepting_cpos;
			     schema_current_state =  schema_last_accepting_state;
			goto  schema_find_action;
			}
		    }

		else switch (  schema_get_next_buffer() )
		    {
		    case EOB_ACT_END_OF_FILE:
			{
			 schema_did_buffer_switch_on_eof = 0;

			if (  schemawrap() )
			    {
			    /* note: because we've taken care in
			     *  schema_get_next_buffer() to have set up  schematext,
			     * we can now set up  schema_c_buf_p so that if some
			     * total hoser (like flex itself) wants
			     * to call the scanner after we return the
			     *  schema_NULL, it'll still work - another  schema_NULL
			     * will get returned.
			     */
			     schema_c_buf_p =  schematext +  schema_MORE_ADJ;

			     schema_act =  schema_STATE_EOF(( schema_start - 1) / 2);
			    goto do_action;
			    }

			else
			    {
			    if ( !  schema_did_buffer_switch_on_eof )
				 schema_NEW_FILE;
			    }
			}
			break;

		    case EOB_ACT_CONTINUE_SCAN:
			 schema_c_buf_p =  schematext +  schema_amount_of_matched_text;

			 schema_current_state =  schema_get_previous_state();

			 schema_cp =  schema_c_buf_p;
			 schema_bp =  schematext +  schema_MORE_ADJ;
			goto  schema_match;

		    case EOB_ACT_LAST_MATCH:
			 schema_c_buf_p =
			    & schema_current_buffer-> schema_ch_buf[ schema_n_chars];

			 schema_current_state =  schema_get_previous_state();

			 schema_cp =  schema_c_buf_p;
			 schema_bp =  schematext +  schema_MORE_ADJ;
			goto  schema_find_action;
		    }
		break;
		}

	    default:
#ifdef FLEX_DEBUG
		printf( "action # %d\n",  schema_act );
#endif
		 schema_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	    }
	}
    }


/*  schema_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int  schema_get_next_buffer();
 *     
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH - 
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */

static int  schema_get_next_buffer()

    {
    register  schema_CHAR *dest =  schema_current_buffer-> schema_ch_buf;
    register  schema_CHAR *source =  schematext - 1; /* copy prev. char, too */
    register int number_to_move, i;
    int ret_val;

    if (  schema_c_buf_p > & schema_current_buffer-> schema_ch_buf[ schema_n_chars + 1] )
	 schema_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

    /* try to read more data */

    /* first move last chars to start of buffer */
    number_to_move =  schema_c_buf_p -  schematext;

    for ( i = 0; i < number_to_move; ++i )
	*(dest++) = *(source++);

    if (  schema_current_buffer-> schema_eof_status != EOF_NOT_SEEN )
	/* don't do the read, it's not guaranteed to return an EOF,
	 * just force an EOF
	 */
	 schema_n_chars = 0;

    else
	{
	int num_to_read =  schema_current_buffer-> schema_buf_size - number_to_move - 1;

	if ( num_to_read >  schema_READ_BUF_SIZE )
	    num_to_read =  schema_READ_BUF_SIZE;

	else if ( num_to_read <= 0 )
	     schema_FATAL_ERROR( "fatal error - scanner input buffer overflow" );

	/* read in more data */
	 schema_INPUT( (& schema_current_buffer-> schema_ch_buf[number_to_move]),
		   schema_n_chars, num_to_read );
	}

    if (  schema_n_chars == 0 )
	{
	if ( number_to_move == 1 )
	    {
	    ret_val = EOB_ACT_END_OF_FILE;
	     schema_current_buffer-> schema_eof_status = EOF_DONE;
	    }

	else
	    {
	    ret_val = EOB_ACT_LAST_MATCH;
	     schema_current_buffer-> schema_eof_status = EOF_PENDING;
	    }
	}

    else
	ret_val = EOB_ACT_CONTINUE_SCAN;

     schema_n_chars += number_to_move;
     schema_current_buffer-> schema_ch_buf[ schema_n_chars] =  schema_END_OF_BUFFER_CHAR;
     schema_current_buffer-> schema_ch_buf[ schema_n_chars + 1] =  schema_END_OF_BUFFER_CHAR;

    /*  schematext begins at the second character in  schema_ch_buf; the first
     * character is the one which preceded it before reading in the latest
     * buffer; it needs to be kept around in case it's a newline, so
     *  schema_get_previous_state() will have with '^' rules active
     */

     schematext = & schema_current_buffer-> schema_ch_buf[1];

    return ( ret_val );
    }


/*  schema_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *      schema_state_type  schema_get_previous_state();
 */

static  schema_state_type  schema_get_previous_state()

    {
    register  schema_state_type  schema_current_state;
    register  schema_CHAR * schema_cp;

    register  schema_CHAR * schema_bp =  schematext;

     schema_current_state =  schema_start;
    if (  schema_bp[-1] == '\n' )
	++ schema_current_state;

    for (  schema_cp =  schematext +  schema_MORE_ADJ;  schema_cp <  schema_c_buf_p; ++ schema_cp )
	{
	register  schema_CHAR  schema_c = (* schema_cp ?  schema_ec[* schema_cp] : 1);
	if (  schema_accept[ schema_current_state] )
	    {
	     schema_last_accepting_state =  schema_current_state;
	     schema_last_accepting_cpos =  schema_cp;
	    }
	while (  schema_chk[ schema_base[ schema_current_state] +  schema_c] !=  schema_current_state )
	    {
	     schema_current_state =  schema_def[ schema_current_state];
	    if (  schema_current_state >= 164 )
		 schema_c =  schema_meta[ schema_c];
	    }
	 schema_current_state =  schema_nxt[ schema_base[ schema_current_state] +  schema_c];
	}

    return (  schema_current_state );
    }


/*  schema_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state =  schema_try_NUL_trans( current_state );
 */

#ifdef  schema_USE_PROTOS
static  schema_state_type  schema_try_NUL_trans( register  schema_state_type  schema_current_state )
#else
static  schema_state_type  schema_try_NUL_trans(  schema_current_state )
register  schema_state_type  schema_current_state;
#endif

    {
    register int  schema_is_jam;
    register  schema_CHAR * schema_cp =  schema_c_buf_p;

    register  schema_CHAR  schema_c = 1;
    if (  schema_accept[ schema_current_state] )
	{
	 schema_last_accepting_state =  schema_current_state;
	 schema_last_accepting_cpos =  schema_cp;
	}
    while (  schema_chk[ schema_base[ schema_current_state] +  schema_c] !=  schema_current_state )
	{
	 schema_current_state =  schema_def[ schema_current_state];
	if (  schema_current_state >= 164 )
	     schema_c =  schema_meta[ schema_c];
	}
     schema_current_state =  schema_nxt[ schema_base[ schema_current_state] +  schema_c];
     schema_is_jam = ( schema_current_state == 163);

    return (  schema_is_jam ? 0 :  schema_current_state );
    }


#ifdef  schema_USE_PROTOS
static void  schemaunput(  schema_CHAR c, register  schema_CHAR * schema_bp )
#else
static void  schemaunput( c,  schema_bp )
 schema_CHAR c;
register  schema_CHAR * schema_bp;
#endif

    {
    register  schema_CHAR * schema_cp =  schema_c_buf_p;

    /* undo effects of setting up  schematext */
    * schema_cp =  schema_hold_char;

    if (  schema_cp <  schema_current_buffer-> schema_ch_buf + 2 )
	{ /* need to shift things up to make room */
	register int number_to_move =  schema_n_chars + 2; /* +2 for EOB chars */
	register  schema_CHAR *dest =
	    & schema_current_buffer-> schema_ch_buf[ schema_current_buffer-> schema_buf_size + 2];
	register  schema_CHAR *source =
	    & schema_current_buffer-> schema_ch_buf[number_to_move];

	while ( source >  schema_current_buffer-> schema_ch_buf )
	    *--dest = *--source;

	 schema_cp += dest - source;
	 schema_bp += dest - source;
	 schema_n_chars =  schema_current_buffer-> schema_buf_size;

	if (  schema_cp <  schema_current_buffer-> schema_ch_buf + 2 )
	     schema_FATAL_ERROR( "flex scanner push-back overflow" );
	}

    if (  schema_cp >  schema_bp &&  schema_cp[-1] == '\n' )
	 schema_cp[-2] = '\n';

    *-- schema_cp = c;

    /* note: the formal parameter *must* be called " schema_bp" for this
     *       macro to now work correctly
     */
     schema_DO_BEFORE_ACTION; /* set up  schematext again */
    }


#ifdef __cplusplus
static int  schemainput()
#else
static int input()
#endif

    {
    int c;
     schema_CHAR * schema_cp =  schema_c_buf_p;

    * schema_cp =  schema_hold_char;

    if ( * schema_c_buf_p ==  schema_END_OF_BUFFER_CHAR )
	{
	/*  schema_c_buf_p now points to the character we want to return.
	 * If this occurs *before* the EOB characters, then it's a
	 * valid NUL; if not, then we've hit the end of the buffer.
	 */
	if (  schema_c_buf_p < & schema_current_buffer-> schema_ch_buf[ schema_n_chars] )
	    /* this was really a NUL */
	    * schema_c_buf_p = '\0';

	else
	    { /* need more input */
	     schematext =  schema_c_buf_p;
	    ++ schema_c_buf_p;

	    switch (  schema_get_next_buffer() )
		{
		case EOB_ACT_END_OF_FILE:
		    {
		    if (  schemawrap() )
			{
			 schema_c_buf_p =  schematext +  schema_MORE_ADJ;
			return ( EOF );
			}

		     schema_NEW_FILE;

#ifdef __cplusplus
		    return (  schemainput() );
#else
		    return ( input() );
#endif
		    }
		    break;

		case EOB_ACT_CONTINUE_SCAN:
		     schema_c_buf_p =  schematext +  schema_MORE_ADJ;
		    break;

		case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
		     schema_FATAL_ERROR( "unexpected last match in  schemainput()" );
#else
		     schema_FATAL_ERROR( "unexpected last match in input()" );
#endif
		}
	    }
	}

    c = * schema_c_buf_p;
     schema_hold_char = *++ schema_c_buf_p;

    return ( c );
    }


#ifdef  schema_USE_PROTOS
void  schemarestart( FILE *input_file )
#else
void  schemarestart( input_file )
FILE *input_file;
#endif

    {
     schema_init_buffer(  schema_current_buffer, input_file );
     schema_load_buffer_state();
    }


#ifdef  schema_USE_PROTOS
void  schema_switch_to_buffer(  schema_BUFFER_STATE new_buffer )
#else
void  schema_switch_to_buffer( new_buffer )
 schema_BUFFER_STATE new_buffer;
#endif

    {
    if (  schema_current_buffer == new_buffer )
	return;

    if (  schema_current_buffer )
	{
	/* flush out information for old buffer */
	* schema_c_buf_p =  schema_hold_char;
	 schema_current_buffer-> schema_buf_pos =  schema_c_buf_p;
	 schema_current_buffer-> schema_n_chars =  schema_n_chars;
	}

     schema_current_buffer = new_buffer;
     schema_load_buffer_state();

    /* we don't actually know whether we did this switch during
     * EOF ( schemawrap()) processing, but the only time this flag
     * is looked at is after  schemawrap() is called, so it's safe
     * to go ahead and always set it.
     */
     schema_did_buffer_switch_on_eof = 1;
    }


#ifdef  schema_USE_PROTOS
void  schema_load_buffer_state( void )
#else
void  schema_load_buffer_state()
#endif

    {
     schema_n_chars =  schema_current_buffer-> schema_n_chars;
     schematext =  schema_c_buf_p =  schema_current_buffer-> schema_buf_pos;
     schemain =  schema_current_buffer-> schema_input_file;
     schema_hold_char = * schema_c_buf_p;
    }


#ifdef  schema_USE_PROTOS
 schema_BUFFER_STATE  schema_create_buffer( FILE *file, int size )
#else
 schema_BUFFER_STATE  schema_create_buffer( file, size )
FILE *file;
int size;
#endif

    {
     schema_BUFFER_STATE b;

    b = ( schema_BUFFER_STATE) malloc( sizeof( struct  schema_buffer_state ) );

    if ( ! b )
	 schema_FATAL_ERROR( "out of dynamic memory in  schema_create_buffer()" );

    b-> schema_buf_size = size;

    /*  schema_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b-> schema_ch_buf = ( schema_CHAR *) malloc( (unsigned) (b-> schema_buf_size + 2) );

    if ( ! b-> schema_ch_buf )
	 schema_FATAL_ERROR( "out of dynamic memory in  schema_create_buffer()" );

     schema_init_buffer( b, file );

    return ( b );
    }


#ifdef  schema_USE_PROTOS
void  schema_delete_buffer(  schema_BUFFER_STATE b )
#else
void  schema_delete_buffer( b )
 schema_BUFFER_STATE b;
#endif

    {
    if ( b ==  schema_current_buffer )
	 schema_current_buffer = ( schema_BUFFER_STATE) 0;

    free( (char *) b-> schema_ch_buf );
    free( (char *) b );
    }


#ifdef  schema_USE_PROTOS
void  schema_init_buffer(  schema_BUFFER_STATE b, FILE *file )
#else
void  schema_init_buffer( b, file )
 schema_BUFFER_STATE b;
FILE *file;
#endif

    {
    b-> schema_input_file = file;

    /* we put in the '\n' and start reading from [1] so that an
     * initial match-at-newline will be true.
     */

    b-> schema_ch_buf[0] = '\n';
    b-> schema_n_chars = 1;

    /* we always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b-> schema_ch_buf[1] =  schema_END_OF_BUFFER_CHAR;
    b-> schema_ch_buf[2] =  schema_END_OF_BUFFER_CHAR;

    b-> schema_buf_pos = &b-> schema_ch_buf[1];

    b-> schema_eof_status = EOF_NOT_SEEN;
    }

